# 1주차: 1장 전략패턴

---

# 🦆

## 1. SimUDuck 게임

오리 시뮬레이션 게임을 만드는 회사에 다님 (SimUDuck)

처음엔 단순하게 `Duck` 클래스를 만들고 기본 행동들을 정의

모든 오리가 꽥꽥거리고 헤엄을 칠 수 있음

display만 별도로 구현(추상메소드)

```python
class Duck:
    def quack(self):
        print("꽥꽥!")

    def swim(self):
        print("오리가 수영합니다.")

    def display(self):
        pass  # 오리별로 다르게 볼 수 있음

```

그리고 클래스가 `Duck`을 상속받아 `display()`만 오버라이딩하는 구조

👉 처음엔 깔끔해 보임

---

## 2. Fly 메서드 추가 → 문제 발생

오리가 날 수 있도록 `fly()` 메서드를 추가

그런데 고무오리도 날아버리는 상황 → 고무오리는 날면 안됨

```python
class Duck:
    def fly(self):
        print("오리가 날아갑니다.")  # 모든 오리가 날아감
```

해당 코드 사용 시

- RubberDuck도 날아버림 → 현실과 다름
- 오리 종류가 늘어날수록 코드 중복, 수정 포인트 증가
- 유지보수가 어려움

 상속으로는 특정 오리만 날게/못 날게 제어하기가 점점 힘듦

---

## 3. 상속의 한계와 해결책

- 상속 구조에서 `fly()`를 오버라이딩하면 코드 중복이 발생
- 오리 종류가 많아질수록 유지보수가 더욱 힘듦
- 따라서 변화하는 부분은 따로 분리

👉 바뀌는 부분과 바뀌지 않는 부분을 분리해야 하는 중요성

👉 따라서 행동부분을 분리하기로 결정

---

## 4. 행동 분리하기 → Behavior

행동분리 → `인터페이스`(파이썬 : 추상 클래스)

```python
from abc import ABC, abstractmethod

# ABC는 추상클래스를 선언
# @abstractmethod 를 붙혀야 추상 메서드로 구현됨

# class 이름(ABC)
#    @abstractmethod
#    def 메서드이름(self):
#        pass

# FlyBehavior 라는 추상클래스를 만들어서
# 날거나 날지 못하는 경우를 각각 만들어줌

class FlyBehavior(ABC): 
    @abstractmethod 
    def fly(self):
        pass

class FlyWithWings(FlyBehavior):
    def fly(self):
        print("날개로 납니다!")

class FlyNoWay(FlyBehavior):
    def fly(self):
        print("저는 못 날아요.")
        
# QuackBehavior 추상클래스로
# 울거나 울지못하는 경우를 각각 만들어줌
class QuackBehavior(ABC):
    @abstractmethod
    def quack(self):
        pass

class Quack(QuackBehavior):
    def quack(self):
        print("꽥꽥!")

class MuteQuack(QuackBehavior):
    def quack(self):
        print("<< 조용 >>")
```

👉 이렇게 사용을 하게 되면 유지보수가 쉬움

- 새의 울음소리를 추가하고싶음 → 새로운 QuackBehavior 클래스를 만듬
- 새가 날다가 로켓을 타게하고싶음 → 새로운 FlyBehavior 클래스를 만듬

---

## 5. 오리 클래스와 행동 위임

이제 `Duck` 클래스는 행동 직접 구현하지 않고 행동 객체에 위임하게 됨

```python
class Duck:
    def __init__(self, fly_behavior: FlyBehavior, quack_behavior: QuackBehavior):
        self.fly_behavior = fly_behavior
        self.quack_behavior = quack_behavior

    def perform_fly(self):
        self.fly_behavior.fly()

    def perform_quack(self):
        self.quack_behavior.quack()

    def swim(self):
        print("오리가 수영합니다.")
```

구체적인 오리 정의:

```python
class MallardDuck(Duck):
    def __init__(self):
        super().__init__(FlyWithWings(), Quack())

    def display(self):
        print("저는 청둥오리입니다.")
```

---

## 6. 동적으로 행동 지정

런타임에 중간에 행동을 바꾸고 싶을 때는 

duck의 서브 클래서에서 setter 메서드를 호출해서 설정함

```python
class Duck:
    def set_fly_behavior(self, fb: FlyBehavior):
        self.fly_behavior = fb

    def set_quack_behavior(self, qb: QuackBehavior):
        self.quack_behavior = qb
```

테스트:

```python
if __name__ == "__main__":
    model = MallardDuck()
    model.display()
    model.perform_fly()

    model.set_fly_behavior(FlyNoWay())
    model.perform_fly()
```

✅ 실행 결과:

```
저는 청둥오리입니다.
날개로 납니다!
저는 못 날아요.
```

✍️ 예시로 날게 행동을 지정했지만 로켓에 의한 추진력 등 다양하게 가능함

✍️ 실행 중 오리의 행동을 바꾸고 싶다면 원하는 행동에 해당하는 duck의 세터매소드를 호출한다

---

## 7. 전략 패턴

- **정의**: 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해줌
- **핵심 원칙**
    1. 바뀌는 부분은 따로 분리
    2. 상속보다 구성을 활용
    3. 구현보다는 인터페이스(추상화)에 맞춰 프로그래밍

---

## 8. 이해

- 단순 상속은 코드 재사용에는 좋아도, 변화 관리에는 취약. (고무오리가 날아다니는 등)
- 전략 패턴은 "행동을 외부로 분리"해서 확장성과 유연성을 확보. (행동별로 따로 만들어 놓기)
- 파이썬에선 인터페이스 대신 추상 클래스로 구현 가능
- 새로운 행동이 추가되더라도 기존 오리 클래스 수정이 필요 없음
