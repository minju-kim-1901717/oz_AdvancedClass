

## 🍕 추상 팩토리 패턴 (Abstract Factory Pattern)

### 🧩 용어 정리

**추상 팩토리(Abstract Factory)**  
서로 관련된 객체들을 생성하기 위한 인터페이스 제공  
팩토리 메서드보다 더 추상적인 개념  
여러 객체를 한 번에 만들어야 할 때 쓰임  

**팩토리 메서드(Factory Method)**  
객체 생성 책임을 하위 클래스로 옮기는 패턴  

**의존성 역전 원칙(DIP, Dependency Inversion Principle)**  
상위 모듈과 하위 모듈이 추상화에 의존하게 하라는 원칙  

---

### 🏗 왜 이 패턴이 필요했나

팩토리 메서드만 쓰면 피자 가게 구조는 분리할 수 있지만  
각 지역의 재료가 다르면 여전히 코드 안에서 재료를 골라야 했고  
if 문이 많아지고 결합도가 높아지는 문제가 생겼음  

예로  
- 뉴욕은 `ThinCrustDough`, `MarinaraSauce`, `ReggianoCheese`  
- 시카고는 `ThickCrustDough`, `PlumTomatoSauce`, `MozzarellaCheese`  

결국 피자 클래스 안에 지역별 조건문이 잔뜩 생기게 됐고  
새 지역 추가할 때마다 수정해야 하는 구조가 됐던 거지  

---

### 🧱 핵심 아이디어

“제품을 만드는 공장을 한 번 더 감싸자”  
즉, 재료를 생산하는 **재료 공장(Ingredient Factory)** 인터페이스를 만들고  
각 지역별 구현체로 분리하는 방식  

```java
public interface PizzaIngredientFactory {
    Dough createDough();
    Sauce createSauce();
    Cheese createCheese();
    Veggies createVeggies();
    Pepperoni createPepperoni();
    Clams createClam();
}
````

지역별 구현체 예:

```java
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
    public Dough createDough() { return new ThinCrustDough(); }
    public Sauce createSauce() { return new MarinaraSauce(); }
    public Cheese createCheese() { return new ReggianoCheese(); }
    public Clams createClam() { return new FreshClams(); }
}
```

```java
public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {
    public Dough createDough() { return new ThickCrustDough(); }
    public Sauce createSauce() { return new PlumTomatoSauce(); }
    public Cheese createCheese() { return new MozzarellaCheese(); }
    public Clams createClam() { return new FrozenClams(); }
}
```

---

### 🍕 피자 클래스 구조 바꾸기

이제 `Pizza`는 재료 만드는 책임이 없음
팩토리에서 받은 재료로만 조립하면 됨

```java
public class CheesePizza extends Pizza {
    PizzaIngredientFactory ingredientFactory;

    public CheesePizza(PizzaIngredientFactory ingredientFactory) {
        this.ingredientFactory = ingredientFactory;
    }

    void prepare() {
        System.out.println("준비 중: " + name);
        dough = ingredientFactory.createDough();
        sauce = ingredientFactory.createSauce();
        cheese = ingredientFactory.createCheese();
    }
}
```

이전처럼 재료가 내부에 숨어 있는 게 아니라,
“이 공장에서 받은 재료로 조립”하는 구조가 되는 셈

---

### 🏪 PizzaStore와의 연결

각 지역 `PizzaStore`는 자기 지역에 맞는 재료 공장 선택

```java
public class NYPizzaStore extends PizzaStore {
    protected Pizza createPizza(String item) {
        Pizza pizza = null;
        PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();

        if (item.equals("cheese")) {
            pizza = new CheesePizza(ingredientFactory);
            pizza.setName("뉴욕 스타일 치즈 피자");
        }
        return pizza;
    }
}
```

시카고 쪽은 이렇게:

```java
public class ChicagoPizzaStore extends PizzaStore {
    protected Pizza createPizza(String item) {
        Pizza pizza = null;
        PizzaIngredientFactory ingredientFactory = new ChicagoPizzaIngredientFactory();

        if (item.equals("cheese")) {
            pizza = new CheesePizza(ingredientFactory);
            pizza.setName("시카고 스타일 치즈 피자");
        }
        return pizza;
    }
}
```

---

### 🧠 의존성 뒤집기 원칙 적용

이제 `Pizza` 클래스는 구체적인 재료 클래스 (`ThinCrustDough`, `PlumTomatoSauce` 등)에 의존하지 않아
대신 `PizzaIngredientFactory`라는 **추상화된 인터페이스**에만 의존

그래서 새 지역 추가할 때 기존 코드는 전혀 수정할 필요 없이
팩토리만 추가하면 됨

---

### 🔁 팩토리 메서드 vs 추상 팩토리

| 구분  | 팩토리 메서드                             | 추상 팩토리                                                      |
| --- | ----------------------------------- | ----------------------------------------------------------- |
| 목적  | 객체 하나 생성                            | 관련 객체 여러 개를 한 묶음으로 생성                                       |
| 반환  | 단일 객체                               | 여러 종류의 객체                                                   |
| 확장  | 서브클래스 추가                            | 팩토리 구현체 추가                                                  |
| 의존성 | 상위 ↔ 하위 직접 결합                       | 인터페이스 중심 느슨한 결합                                             |
| 예시  | `NYPizzaStore`, `ChicagoPizzaStore` | `NYPizzaIngredientFactory`, `ChicagoPizzaIngredientFactory` |

---

### ✍ 느낀 점

팩토리 메서드가 ‘피자 한 판 만드는 공장’ 느낌이었다면
추상 팩토리는 ‘피자 재료를 만드는 공장’ 같은 느낌이었음

처음엔 구조가 복잡해 보여서 뭔가 머리 아팠는데
공부하면서 보니까 이 패턴이 진짜 설계를 유연하게 만들어 준다는 걸 실감했음

특히 지역별 재료나 방식이 다를 때,
기존 코드를 하나도 안 건드리고 새로운 팩토리만 추가해서 대응할 수 있다는 게 핵심이었음

이해하고 나니까 왜 OO 설계에서
“변화에는 닫고, 확장에는 열려 있어야 한다” 그 말을 강조하는지 약간 감이 왔음

---

## 🔐 JWT (JSON Web Token)

### 🧾 개념 정리

JWT는 로그인한 사용자를 인증하기 위한 **토큰 기반 방식**
서버는 사용자를 인증한 뒤 JWT를 발급하고
클라이언트는 요청할 때마다 이 토큰을 헤더에 담아서 보내
서버는 토큰의 **서명(Signature)** 을 검증해 유효성 판단

JWT는 서버에 상태를 저장하지 않는 **Stateless** 구조라
확장성에 유리함

---

### 🍪 쿠키 / 세션 / JWT 비교

| 구분          | 쿠키    | 세션           | JWT                     |
| ----------- | ----- | ------------ | ----------------------- |
| 저장 위치       | 브라우저  | 서버           | 클라이언트                   |
| 서버 상태 필요 여부 | 있음    | 있음           | 없음                      |
| 장점          | 간단함   | 상대적 안정성      | 확장성 좋음, 다양한 환경에 사용 가능   |
| 단점          | 보안 취약 | 서버 부하/확장 어려움 | 탈취 위험, 토큰 길이 & 만료 관리 필요 |

핵심은 JWT는 서버가 사용자 상태를 기억할 필요 없다는 점
오로지 토큰의 유효성만 검사하면 됨

---

### 🧾 JWT 구조

JWT는 `Header.Payload.Signature` 세 부분으로 구성됨

* **Header** : 서명 알고리즘, 토큰 타입 등 정보 담음
* **Payload** : 사용자 정보나 만료시간 같은 클레임 담음 (민감한 정보 절대 넣지 않기)
* **Signature** : Header + Payload 조합 + 비밀키로 생성, 위변조 방지 역할

> Header와 Payload는 Base64 인코딩이라 복호화 가능
> 따라서 민감 정보는 절대 Payload에 넣으면 안 됨

---

### ⚙ 인증 흐름

1. 클라이언트가 ID/비밀번호로 로그인 요청
2. 서버가 인증 후 JWT 발급
3. 클라이언트는 토큰을 저장하고, 이후 요청 시 헤더에 포함
4. 서버는 토큰의 서명을 검증해 유효 여부 판단

---

### 🔑 Access vs Refresh Token

* **Access Token** : 인증에 사용, 수명이 짧음
* **Refresh Token** : Access 토큰 만료 시 재발급용, 수명은 길게 설정

Access는 짧게 두고
Refresh로 새 Access를 받는 구조로 보안 강화

---

### ✅ 장단점 요약

**장점**

* 서버 상태 저장이 불필요함
* 확장성 우수
* 웹, 앱, 모바일 등 다양한 환경에서 동일하게 사용 가능

**단점**

* 탈취 시 위험
* Payload 노출 가능성
* 만료 & 로그아웃 처리 복잡

---

### ✍ 느낀 점

처음엔 JWT가 세션보다 단순한 인증 방식인 줄 알았는데
공부해 보니까 단순함 너머의 설계가 숨어 있었음

서버에 상태를 저장하지 않고도 인증을 유지할 수 있다는 건 혁신 같았고
하지만 그만큼 토큰 관리, 만료, 보안을 잘 설계해야 한다는 책임도 큼

특히 Access / Refresh 구조를 같이 쓰면서
“짧게 인증 + 다시 발급” 방식이 보안과 사용자 경험 사이 균형을 잘 잡아주는 느낌이었음

결국 JWT는 **무상태 인증의 대표 방식**이고
서버 부담을 줄이면서도 보안성과 유연성을 확보하려는 설계라는 걸 느꼈음

