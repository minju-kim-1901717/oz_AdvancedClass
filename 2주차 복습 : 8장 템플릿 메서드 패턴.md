# 2주차: 8장 템플릿 메서드 패턴

# ☕

---

## 📌 어려운 용어 정리

- **템플릿 메소드 패턴 (Template Method Pattern)**
    
    알고리즘의 뼈대를 상위 클래스에 정의하고, 세부 단계는 하위 클래스에서 구현하는 패턴.
    
- **후크(Hook)**
    
    선택적으로 오버라이드 가능한 메소드. 실행 여부를 하위 클래스에서 결정할 수 있음.
    
- **할리우드 원칙 (Hollywood Principle)**
    
    상위 클래스가 제어를 담당하고 하위 클래스는 필요할 때만 불려옴.
    
- **알고리즘 캡슐화**
    
    변하지 않는 전체 구조와 변하는 부분을 분리해 유지보수를 쉽게 만드는 것.
    
- **Abstract Class (추상 클래스)**
    
    인스턴스화할 수 없고, 공통 동작 + 추상 메소드를 정의하는 클래스.
    
- **primitive operation (원시 연산)**
    
    템플릿 메소드에서 호출하는 추상 메소드(하위 클래스가 반드시 구현).
    

---

## 1. 문제 상황: 커피와 홍차 만들기

- 커피와 홍차는 만드는 과정이 매우 유사함.
    - 물 끓이기 → 재료 우리기 → 컵에 붓기 → 첨가물 추가

👉 하지만 `Coffee` 클래스와 `Tea` 클래스를 따로 작성하면 중복 코드가 너무 많아짐

→ 공통된 알고리즘을 추출하고, 변하는 부분만 따로 두는 게 필요

---

## 2. Coffee와 Tea 클래스 **(템플릿 메서드 패턴 이전)**

```python
class Coffee:
    def prepare_recipe(self):
        self.boil_water()
        self.brew_coffee_grinds()
        self.pour_in_cup()
        self.add_sugar_and_milk()

    def boil_water(self): print("물을 끓이는 중")
    def brew_coffee_grinds(self): print("커피 가루를 우려내는 중")
    def pour_in_cup(self): print("컵에 따르는 중")
    def add_sugar_and_milk(self): print("설탕과 우유를 추가하는 중")

class Tea:
    def prepare_recipe(self):
        self.boil_water()
        self.steep_tea_bag()
        self.pour_in_cup()
        self.add_lemon()

    def boil_water(self): print("물을 끓이는 중")
    def steep_tea_bag(self): print("티백을 우리기")
    def pour_in_cup(self): print("컵에 따르는 중")
    def add_lemon(self): print("레몬 추가")
```

**실행 결과**

```python
Coffee().prepare_recipe()
물을 끓이는 중
커피 가루를 우려내는 중
컵에 따르는 중
설탕과 우유를 추가하는 중

Tea().prepare_recipe()
물을 끓이는 중
티백을 우리기
컵에 따르는 중
레몬 추가

```

✍️ `prepareRecipe()` 알고리즘이 사실상 동일한데, 중복됨 → **템플릿 메소드 패턴 필요**

---

## 3. 추상화: CaffeineBeverage (템플릿 클래스)

```python
from abc import ABC, abstractmethod

class CaffeineBeverage(ABC):
    def prepare_recipe(self):   # 템플릿 메소드
        self.boil_water()
        self.brew()
        self.pour_in_cup()
        self.add_condiments()

    @abstractmethod
    def brew(self): pass

    @abstractmethod
    def add_condiments(self): pass

    def boil_water(self): print("물을 끓이는 중")
    def pour_in_cup(self): print("컵에 따르는 중")

```

→ 물 끓이기 & 컵에 따르기를 중복 없이 한 번에 구현

---

## 4. 하위 클래스에서 구현

```python
class Tea(CaffeineBeverage):
    def brew(self): print("티백을 우리기")
    def add_condiments(self): print("레몬 추가")

class Coffee(CaffeineBeverage):
    def brew(self): print("커피 가루 우려내기")
    def add_condiments(self): print("설탕과 우유 추가")
```

**실행 결과 → 위와 동일함**

---

## 5. 후크 메소드(Hook)

```python
class CaffeineBeverageWithHook(CaffeineBeverage):
    def prepare_recipe(self):
        self.boil_water()
        self.brew()
        self.pour_in_cup()
        if self.customer_wants_condiments():
            self.add_condiments()

    def customer_wants_condiments(self):  # 후크 메소드
        return True
```

→ 하위 클래스에서 오버라이딩하여 조건부 실행 가능

**예시**

```python
class TeaWithHook(CaffeineBeverageWithHook):
    def brew(self): print("티백을 우리기")
    def add_condiments(self): print("레몬 추가")

    def customer_wants_condiments(self):
        answer = input("레몬을 추가하시겠습니까? (y/n): ")
        return answer.lower().startswith('y')
```

---

## 6. 할리우드 원칙 (Hollywood Principle)

> "먼저 연락하지 마세요, 저희가 연락 드리겠습니다."
> 
- 상위 클래스가 알고리즘 흐름을 제어
- 하위 클래스는 필요한 역할만 수행
- 템플릿 메소드 패턴은 이 원칙을 구현한 대표적인 예시

---

## 7. 템플릿 메소드 패턴 정리

- **정의:** 알고리즘의 뼈대를 정의하고, 일부 단계를 하위 클래스에서 구현하게 하는 패턴
- **장점:**
    - 코드 중복 제거
    - 알고리즘 일관성 유지
    - 선택적 동작은 후크로 유연하게 처리 가능
- **원칙:**
    1. 변하지 않는 부분과 변하는 부분을 분리
    2. 상위 클래스가 전체 제어 담당 (**할리우드 원칙**)
    3. 상속을 활용하지만, 제어 흐름은 상위 클래스가 가짐

---

## ✍️ 내가 이해하고 느낀 점

- 템플릿 메소드 패턴은 알고리즘의 큰 틀은 고정하고, 세부 단계만 하위 클래스에서 구현한다는 점이 핵심
- 이렇게 하면 중복 코드를 줄이고 전체 흐름의 일관성을 유지하면서도, 필요한 부분은 유연하게 확장할 수 있다
- 전략 패턴과 비교하면,
    - 전략은 행동 자체를 외부 객체로 분리해서 교체할 수 있게 하는 방식이고
    - 템플릿은 알고리즘 구조를 상위 클래스에서 고정한 채 세부 단계만 다르게 구현하는 방식이라는 차이가 있다
- 결국 중요한 건 변화하는 부분과 변하지 않는 부분을 분리해서 코드 관리와 확장을 쉽게 만드는 것이며, 템플릿 메소드 패턴은 그걸 잘 보여주는 예시라고 느꼈다
